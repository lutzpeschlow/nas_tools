
// func main() {
//
// 	type NastranModel struct {
// 		Nodes map[int]*Node // GRID: ID -> Node
// 		//	Elements   map[int]Element   // CBEAM, CTRIA3 etc.: ID -> Element (Interface)
// 		//	Properties map[int]Property  // PSHELL, PBAR etc.: ID -> Property (Interface)
// 		//	Materials  map[int]*Material // MAT1: ID -> Material
// 		//	Loads      map[int]*Load     // FORCE, SPC: ID -> Load
// 		// Weitere: Sets, Constraints etc.
// 	}
// 	type Node struct {
// 		ID      int
// 		CP      int // Coordinate system
// 		X, Y, Z float64
// 		CD      int // Displacement coord system
// 		PS      int // Permanent single-point constraints
// 	}
//
// 	var my_string string
// 	my_string = "nas_tools"
// 	fmt.Print("  ..  ", my_string, "\n")
//
// }

//	type Element interface {
//		ID() int
//		Pid() int // Property ID
//		NodeIDs() []int
//		Type() string // "CBEAM", "CTRIA3"
//	}
//
//	// Property-Interface
//	type Property interface {
//		ID() int
//		Mid() int // Material ID
//		Type() string
//	}
//	type BeamElement struct { // CBEAM
//		id     int
//		pid    int
//		n1, n2 int // Endknoten
//		orient int // Orientation vector/grid
//	}
//
//	type PShell struct {
//		Id   int
//		Mid1 int // Membran-Material
//		Mid2 int // Biegung (optional)
//		Mid3 int // Scherung (optional)
//		Mid4 int // Membran-Schub (optional)
//
//		T   float64 // Grunddicke
//		Nsm float64 // Nicht-strukturelle Masse
//		Z1  float64 // Obere Faserlage
//		Z2  float64 // Untere Faserlage
//
//		// optional: Dicken-Skalierung, Integration-Flag etc.
//	}
//
//	type ShellProperty struct { // PSHELL
//		id  int
//		mid int     // Material ID
//		t   float64 // Thickness
//		// Tflags, Ti für variable Dicken
//	}
//
//	type BarProperty struct { // PBAR: Querschnitt für Balken
//		id        int
//		mid       int
//		A, I1, I2 float64 // Area, Momente etc.
//		// Vollständig: 10+ Felder wie J, NSI etc.
//	}
//	type Material struct { // MAT1
//		ID      int
//		E       float64 // Young's modulus
//		G       float64 // Shear modulus
//		Nu      float64 // Poisson's ratio
//		Rho     float64 // Density
//		A, Tref float64
//	}
//
//	type Load struct { // FORCE/SPC
//		ID   int
//		Type string // "FORCE", "SPC"
//		Nid  int    // Node ID
//		Mag  float64
//		Dir  int // DOF 1-6
//		// Für FORCE: Scale, CID; für SPC: Components "123456"
//	}

// func (e *BeamElement) ID() int { return e.id }
// func (e *BeamElement) Pid() int { return e.pid }
// func (e *BeamElement) NodeIDs() []int { return []int{e.n1, e.n2} }
// func (e *BeamElement) Type() string { return "CBEAM" }
// func (p *PShell) ID() int   { return p.Id }
// func (p *PShell) Mid() int  { return p.Mid1 }
// func (p *PShell) Type() string { return "PSHELL" }
// func (p *ShellProperty) ID() int { return p.id }
// func (p *ShellProperty) Mid() int { return p.mid }
// func (p *ShellProperty) Type() string { return "PSHELL" }





func readNastranCards(filename string) ([]string, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    var cards []string
    var currentCard strings.Builder

    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        
        // Kommentar-Zeilen überspringen ($)
        if strings.HasPrefix(line, "$") {
            continue
        }
        
        // Leere Zeilen = Kartentrenner
        if line == "" {
            if currentCard.Len() > 0 {
                cards = append(cards, strings.TrimSpace(currentCard.String()))
                currentCard.Reset()
            }
            continue
        }
        
        // Karte anhängen (free format: + für continuation)
        currentCard.WriteString(line + " ")
        
        // Optional: Prüfe auf Continuation-Marker
        if strings.HasSuffix(line, "+") {
            continue // Nächste Zeile anhängen
        }
        
        // Karte fertig → speichern
        cards = append(cards, strings.TrimSpace(currentCard.String()))
        currentCard.Reset()
    }
    
    // Letzte Karte prüfen
    if currentCard.Len() > 0 {
        cards = append(cards, strings.TrimSpace(currentCard.String()))
    }

    return cards, scanner.Err()
}

func main() {
    cards, err := readNastranCards("input.nas")
    if err != nil {
        log.Fatal(err)
    }
    
    for i, card := range cards {
        fmt.Printf("Karte %d: %s\n", i+1, card)
    }
}